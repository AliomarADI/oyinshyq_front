// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'json_api_client.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PlaceHolderClientTearOff {
  const _$PlaceHolderClientTearOff();

  _GetAllToy getAllToy() {
    return const _GetAllToy();
  }

  _GetAllPayments getAllPayments() {
    return const _GetAllPayments();
  }

  _GetAllToyByName getAllToyByName(String name) {
    return _GetAllToyByName(
      name,
    );
  }
}

/// @nodoc
const $PlaceHolderClient = _$PlaceHolderClientTearOff();

/// @nodoc
mixin _$PlaceHolderClient {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllToy,
    required TResult Function() getAllPayments,
    required TResult Function(String name) getAllToyByName,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAllToy value) getAllToy,
    required TResult Function(_GetAllPayments value) getAllPayments,
    required TResult Function(_GetAllToyByName value) getAllToyByName,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlaceHolderClientCopyWith<$Res> {
  factory $PlaceHolderClientCopyWith(
          PlaceHolderClient value, $Res Function(PlaceHolderClient) then) =
      _$PlaceHolderClientCopyWithImpl<$Res>;
}

/// @nodoc
class _$PlaceHolderClientCopyWithImpl<$Res>
    implements $PlaceHolderClientCopyWith<$Res> {
  _$PlaceHolderClientCopyWithImpl(this._value, this._then);

  final PlaceHolderClient _value;
  // ignore: unused_field
  final $Res Function(PlaceHolderClient) _then;
}

/// @nodoc
abstract class _$GetAllToyCopyWith<$Res> {
  factory _$GetAllToyCopyWith(
          _GetAllToy value, $Res Function(_GetAllToy) then) =
      __$GetAllToyCopyWithImpl<$Res>;
}

/// @nodoc
class __$GetAllToyCopyWithImpl<$Res>
    extends _$PlaceHolderClientCopyWithImpl<$Res>
    implements _$GetAllToyCopyWith<$Res> {
  __$GetAllToyCopyWithImpl(_GetAllToy _value, $Res Function(_GetAllToy) _then)
      : super(_value, (v) => _then(v as _GetAllToy));

  @override
  _GetAllToy get _value => super._value as _GetAllToy;
}

/// @nodoc

class _$_GetAllToy extends _GetAllToy with DiagnosticableTreeMixin {
  const _$_GetAllToy() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PlaceHolderClient.getAllToy()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'PlaceHolderClient.getAllToy'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _GetAllToy);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllToy,
    required TResult Function() getAllPayments,
    required TResult Function(String name) getAllToyByName,
  }) {
    return getAllToy();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
  }) {
    return getAllToy?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
    required TResult orElse(),
  }) {
    if (getAllToy != null) {
      return getAllToy();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAllToy value) getAllToy,
    required TResult Function(_GetAllPayments value) getAllPayments,
    required TResult Function(_GetAllToyByName value) getAllToyByName,
  }) {
    return getAllToy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
  }) {
    return getAllToy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
    required TResult orElse(),
  }) {
    if (getAllToy != null) {
      return getAllToy(this);
    }
    return orElse();
  }
}

abstract class _GetAllToy extends PlaceHolderClient {
  const factory _GetAllToy() = _$_GetAllToy;
  const _GetAllToy._() : super._();
}

/// @nodoc
abstract class _$GetAllPaymentsCopyWith<$Res> {
  factory _$GetAllPaymentsCopyWith(
          _GetAllPayments value, $Res Function(_GetAllPayments) then) =
      __$GetAllPaymentsCopyWithImpl<$Res>;
}

/// @nodoc
class __$GetAllPaymentsCopyWithImpl<$Res>
    extends _$PlaceHolderClientCopyWithImpl<$Res>
    implements _$GetAllPaymentsCopyWith<$Res> {
  __$GetAllPaymentsCopyWithImpl(
      _GetAllPayments _value, $Res Function(_GetAllPayments) _then)
      : super(_value, (v) => _then(v as _GetAllPayments));

  @override
  _GetAllPayments get _value => super._value as _GetAllPayments;
}

/// @nodoc

class _$_GetAllPayments extends _GetAllPayments with DiagnosticableTreeMixin {
  const _$_GetAllPayments() : super._();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PlaceHolderClient.getAllPayments()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PlaceHolderClient.getAllPayments'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _GetAllPayments);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllToy,
    required TResult Function() getAllPayments,
    required TResult Function(String name) getAllToyByName,
  }) {
    return getAllPayments();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
  }) {
    return getAllPayments?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
    required TResult orElse(),
  }) {
    if (getAllPayments != null) {
      return getAllPayments();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAllToy value) getAllToy,
    required TResult Function(_GetAllPayments value) getAllPayments,
    required TResult Function(_GetAllToyByName value) getAllToyByName,
  }) {
    return getAllPayments(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
  }) {
    return getAllPayments?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
    required TResult orElse(),
  }) {
    if (getAllPayments != null) {
      return getAllPayments(this);
    }
    return orElse();
  }
}

abstract class _GetAllPayments extends PlaceHolderClient {
  const factory _GetAllPayments() = _$_GetAllPayments;
  const _GetAllPayments._() : super._();
}

/// @nodoc
abstract class _$GetAllToyByNameCopyWith<$Res> {
  factory _$GetAllToyByNameCopyWith(
          _GetAllToyByName value, $Res Function(_GetAllToyByName) then) =
      __$GetAllToyByNameCopyWithImpl<$Res>;
  $Res call({String name});
}

/// @nodoc
class __$GetAllToyByNameCopyWithImpl<$Res>
    extends _$PlaceHolderClientCopyWithImpl<$Res>
    implements _$GetAllToyByNameCopyWith<$Res> {
  __$GetAllToyByNameCopyWithImpl(
      _GetAllToyByName _value, $Res Function(_GetAllToyByName) _then)
      : super(_value, (v) => _then(v as _GetAllToyByName));

  @override
  _GetAllToyByName get _value => super._value as _GetAllToyByName;

  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_GetAllToyByName(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_GetAllToyByName extends _GetAllToyByName with DiagnosticableTreeMixin {
  const _$_GetAllToyByName(this.name) : super._();

  @override
  final String name;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PlaceHolderClient.getAllToyByName(name: $name)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PlaceHolderClient.getAllToyByName'))
      ..add(DiagnosticsProperty('name', name));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GetAllToyByName &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(name);

  @JsonKey(ignore: true)
  @override
  _$GetAllToyByNameCopyWith<_GetAllToyByName> get copyWith =>
      __$GetAllToyByNameCopyWithImpl<_GetAllToyByName>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getAllToy,
    required TResult Function() getAllPayments,
    required TResult Function(String name) getAllToyByName,
  }) {
    return getAllToyByName(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
  }) {
    return getAllToyByName?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getAllToy,
    TResult Function()? getAllPayments,
    TResult Function(String name)? getAllToyByName,
    required TResult orElse(),
  }) {
    if (getAllToyByName != null) {
      return getAllToyByName(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetAllToy value) getAllToy,
    required TResult Function(_GetAllPayments value) getAllPayments,
    required TResult Function(_GetAllToyByName value) getAllToyByName,
  }) {
    return getAllToyByName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
  }) {
    return getAllToyByName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetAllToy value)? getAllToy,
    TResult Function(_GetAllPayments value)? getAllPayments,
    TResult Function(_GetAllToyByName value)? getAllToyByName,
    required TResult orElse(),
  }) {
    if (getAllToyByName != null) {
      return getAllToyByName(this);
    }
    return orElse();
  }
}

abstract class _GetAllToyByName extends PlaceHolderClient {
  const factory _GetAllToyByName(String name) = _$_GetAllToyByName;
  const _GetAllToyByName._() : super._();

  String get name => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$GetAllToyByNameCopyWith<_GetAllToyByName> get copyWith =>
      throw _privateConstructorUsedError;
}
